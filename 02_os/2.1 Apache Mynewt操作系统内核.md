# 2.1 Apache Mynewt操作系统内核

Mynewt核心操作系统是一个多任务，抢占式的实时操作系统。它将调度器与典型RTOS特性有机的整合在一起，包括互斥量（mutex），信号量（semaphore），内存池等。Mynewt内核还提供了许多有有用的工具，如任务看门狗，网络协议栈内存缓冲区，时间管理API。

多任务，抢占式操作系统是一种可以实例化多个任务，且为每个任务分配优先级。高优先级的任务优先于低优先级任务运行。更进一步，如果一个低优先级任务正在运行，此时一个更高优先级的任务想要运行，那么低优先级的任务将会停止，等待更高优先级的任务运行，即较低优先级任务被高优先级任务抢占了。

**为何使用操作系统？**

你可能会问自己”为什么我需要一个多任务的抢占式操作系统？“，答案可能确实是你并不需要。有些应用非常简单，只需要轮询循环即可。但有更多的应用是复杂的，可能要求某些工作按时执行或在其他工作之前执行。如果你有一个简单轮询循环，你就不能轮换到服务工作，直到当前的工作完成。使用Mynewt OS，应用程序开发者不需要担心特定的任务占用太长时间或不及时执行，操作系统提供了处理这些情况的机制。

使用操作系统的另一个好处在于，它有助于包含应用程序开发人员不受其他应用程序代码编写的影响，开发人员不必担心（或更少担心）其他应用程序的不当行为，导致不受欢迎的行为或阻止他们代码的正确执行。使用操作系统的其他好处是，操作系统还提供了一些特性使得开发者可以创建自己所需要的特性。

**基础应用创建**

使用Mynewt Core OS创建一个应用是一个相对简单的任务，主要步骤有：

1. 为应用安装基础的Newt工具框架（构建框架）。
2. 创建板级支持包，若基于已有平台，直接指定即可。
3. 在应用的*main()*函数中，调用*sysinit()*函数初始化系统与包，执行特定应用程序的初始化，然后在无限循环中等待操作系统从默认事件队列中分配事件。

使用RTOS（实时操作系统）如Mynewt，初始化应用程序模块和任务将变得略微有些复杂。必须注意的是，一个任务提供的API需要在被其他更高优先级任务调用之前完成初始化。

**示例**

如下所示代码，应用程序初始化系统和包，调用特定任务初始化函数，并从默认事件队列分派事件。

应用程序任务初始化函数完成数据结构的初始化，其后将任务添加到系统中。

在这个示例中，任务1释放信号量1，并等待任务2释放信号量2 。由于任务1中释放了信号量1，从而任务2得到运行，释放信号量2，等待信号量1。当信号量2释放后，任务1继续运行，如此往复。

```c
    struct os_sem task1_sem;
    struct os_sem task2_sem;

    /* Task 1 handler function */
    void
    task1_handler(void *arg)
    {
        while (1) {
            /* Release semaphore to task 2 */
            os_sem_release(&task1_sem);

            /* Wait for semaphore from task 2 */
            os_sem_pend(&task2_sem, OS_TIMEOUT_NEVER);
        }
    }

    /* Task 2 handler function */
    void
    task2_handler(void *arg)
    {
        struct os_task *t;

        while (1) {
            /* Wait for semaphore from task1 */
            os_sem_pend(&task1_sem, OS_TIMEOUT_NEVER);

            /* Release task2 semaphore */
            os_sem_release(&task2_sem);
        }
    }


    /* Initialize task 1 exposed data objects */
    void
    task1_init(void)
    {
        /* Initialize task1 semaphore */
        os_sem_init(&task1_sem, 0);
    }

    /* Initialize task 2 exposed data objects */
    void
    task2_init(void)
    {
        /* Initialize task1 semaphore */
        os_sem_init(&task2_sem, 0);
    }

    /**
     * init_app_tasks
     *
     * This function performs initializations that are required before tasks run.
     *
     * @return int 0 success; error otherwise.
     */
    static int
    init_app_tasks(void)
    {
        /*
         * Call task specific initialization functions to initialize any shared objects
         * before initializing the tasks with the OS.
         */
        task1_init();
        task2_init();

        /*
         * Initialize tasks 1 and 2 with the OS.
         */
        os_task_init(&task1, "task1", task1_handler, NULL, TASK1_PRIO,
                     OS_WAIT_FOREVER, task1_stack, TASK1_STACK_SIZE);

        os_task_init(&task2, "task2", task2_handler, NULL, TASK2_PRIO,
                     OS_WAIT_FOREVER, task2_stack, TASK2_STACK_SIZE);

        return 0;
    }

    /**
     * main
     *
     * The main function for the application. This function initializes the system and packages,
     * calls the application specific task initialization function, then waits and dispatches
     * events from the OS default event queue in an infinite loop.
     */
    int
    main(int argc, char **arg)
    {

        /* Perform system and package initialization */
        sysinit();

        /* Initialize application specific tasks */
        init_app_tasks();

        while (1) {
           os_eventq_run(os_eventq_dflt_get());
        }
        /* main never returns */
}
```

## 2.1.1 调度器

调度器的工作是维护任务列表，决定下一刻运行哪个任务。

### 描述

首先说明任务所处的几种状态：运行态（running），就绪态（ready to run）或休眠态（sleeping）。

当任务处于运行态，CPU正在执行任务的上下文。程序计数器（PC）指向要执行任务的指令，堆栈指针（SP）指向任务的栈。

而处于就绪态的任务则希望获得CPU来执行工作。

而处理休眠态的任务则没有工作需要完成，等待特定条件唤醒。

而调度器算法也比较简单：从就绪态的任务中，选择最高优先级的任务（t_prio字段），将其状态设置为运行态。

处于运行态或就绪态的任务将被保存在g_os_run_list链表中，而此列表通过优先级排序。

处于休眠态的任务则保存在g_os_sleep_list链表中。

调度器由一个特定于CPU架构的组件，这段代码负责完成任务运行的切换，此过程称为上下文切换。在上下文切换过程中，当前正在运行的任务的CPU状态将被存储，并切换到新的任务的上下文。

### API

```
struct os_task* os_sched_get_current_task(void)
```

返回值：返回当前运行的任务

注意：返回的任务可能是也可能不是就绪态中最高优先级的任务。

```
void os_sched_set_current_task(struct os_task  *)
```

```
struct os_task* os_sched_next_task(void)
```

```
void os_sched(struct os_task  *)
```

如果需要，执行上下文切换。

如果next_t被设置，任务将被置于运行态。若next_t为NULL，就绪态最高优先级任务将被切换。当前任务切换到休眠态或新的任务切换到就绪态时此函数被调用。

此函数将调用架构特定代码来切换到新任务。

```c
// example
os_error_t
os_mutex_release(struct os_mutex *mu)
{
    ...
    OS_EXIT_CRITICAL(sr);

    // Re-schedule if needed
    if (resched) {
        os_sched(rdy);
    }

    return OS_OK;

}
```

## 2.1.2 任务



参考：

1、http://mynewt.apache.org/latest/os/core_os/task/task.html



## 2.1.3 互斥量



参考：

1、http://mynewt.apache.org/latest/os/core_os/mutex/mutex.html



## 2.1.4 信号量



参考：

1、http://mynewt.apache.org/latest/os/core_os/semaphore/semaphore.html

## 2.1.5 事件队列



## 2.1.6 Callout



## 2.1.7 堆（Heap）



## 2.1.8 内存池



## 2.1.9 缓存（Mbufs）



## 2.1.10 CPU时间



## 2.1.11 OS时间



## 2.1.12 守护任务（Sanity）