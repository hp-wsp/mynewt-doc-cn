# 2.2 系统模块

本小节介绍Apache Mynewt操作系统内核意外的核心系统功能。包括如何计算统计数据，日志数据以及管理运行Mynewt系统的设备的配置。

## 2.2.1 配置

配置子系统用于包中每个设备配置和运行时状态。

配置项以键值对的形式保存，而键和值都应该是字符串。键被划分为组件元素，其中包使用第一个元素注册它的子树。如键*id/serial*包含了两个组件，id以及serial。包*sys/id*在id下注册了配置元素的子树（sys/id/...）。

有一些方便的操作方式用于进行value的字符串来回转换。

### 处理程序（Handlers）

配置处理程序为子树实现了一组handler函数。他们通过调用*conf_register()*函数注册。

- ch_get，当调用conf_get_value()从配置中获取元素值时，调用此接口
- ch_set，调用conf_set_value()函数设置值，或从持续存储中用conf_load()加载配置时，调用此接口
- ch_commit，在配置被完整加载后调用。有时不希望在没配置一个value就立即生效，比如多个相互依赖的设置。
- ch_export，到处当前所有配置时调用。发生在使用conf_save()试图保存设置，或使用CLI将当前系统配置导出到控制台。

```c
/**
 * Configuration handler, used to register a config item/subtree.
 */
struct conf_handler {
    SLIST_ENTRY(conf_handler) ch_list;
    /**
     * The name of the conifguration item/subtree
     */
    char *ch_name;
    /** Get configuration value */
    conf_get_handler_t ch_get;
    /** Set configuration value */
    conf_set_handler_t ch_set;
    /** Commit configuration value */
    conf_commit_handler_t ch_commit;
    /** Export configuration value */
    conf_export_handler_t ch_export;
};
```

### 持久化

配置的后端存储可以在FCB，文件系统，或二者都使用。

可以为配置声明多个源，当调用conf_load时，所有设置都将重置。

写配置的目标只能有一个，这个就是调用conf_save()或conf_save_one()保存数据的地方。

FCB读目标使用conf_fcb_src()函数，写目标通过conf_fcb_dst()。conf_fcb_src()函数附带初始化FCB区域，因此在调用conf_fcb_dst()时也需要调用此函数。文件读取目标使用conf_file_src()，写目标使用conf_file_dst()。

为了便于一个配置区域的初始化，可以通过设置syscfg变量：CONFIG_FCB或CONFIG_NFFS。它们使用其他syscfg变量来确定BSP的哪个flash_map入口定义了flash区域，或使用哪个文件。检查sys/config包中的syscfg.yml文件可以获得更多的描述。

### CLI

当通过将syscfg变量中的CONFIG_CLI设置1，将使能shell包。

通过CLI，你可以设置配置变量，检查他们的值，并打印已保存的配置和正在运行的配置。

- config dump，导出当前正在运行的配置。
- config dump saved，导出已经保存的撇合作，将按照恢复的顺序打印。
- config <key>，打印key对应的值。
- config <key> <value>，设置变量key的value。



## 2.2.2 日志

Mynewt的日志包支持在Mynewt应用程序中记录日志信息。它允许包用单独的名称定义自己的日志流。它还允许应用程序控制日志的输出目的地。

### 描述

在Mynewt操作系统中，log包有两个版本：

- sys/log/full包，实现完整的日志功能和API
- sys/log/stub包，为API实现存根（stub）

两个包都到处了log应用程序接口，任何使用log应用程序接口的包必须在pkg.yml文件的依赖中声明log：

```yaml
pkg.req_apis:
	- log
```

应用程序的pkg.yml文件指定了log包的版本。若一个项目需要使用完整日志功能，则需要在pgk.yml文件的依赖中声明sys/log/full包：

```yaml
pkg.deps:
	- "@apache-mynewt-core/sys/log/full"
```

如果在应用程序中不需要使用日志记录，可以使用sys/log/stub来减小代码大小。

### Syscfg设置

系统设置LOG_LEVEL允许你在应用程序中启用日志等级。这样只有日志等级等于或高于LOG_LEVEL的日志才允许打印。应用程序中包含的日志记录数量都会影响应用程序的尺寸。LOG_LEVEL_DEBUG为0，包含所有的日志，将LOG_LEVEL设置为255将禁止所有的日志。日志级别在sys/log/full/include/log/log.h文件中通过#define指定，如下设置将日志等级设置为LOG_LEVEL_ERROR。

```yaml
syscfg.vals:
    LOG_LEVEL: 3
```

日志等级：LOG_LEVEL_DEBUG--0，INFO--1，WARN--2，ERROR--3，CRITICAL--4。

每个日志流都需要一个log结构体来定义日志的属性。

```c

```

### 日志处理程序

要使用日志，需要一个日志处理程序完成日志的I/O操作。log包提供了三种预先构建的日志处理程序：

- console，控制台，日志流事件直接记录到控制台端口，但不支持walking和读。
- cbmem，将日志事件读/写到环形缓冲器，支持通过newtmgr和shell命令行walking和读。
- fcb，读/写日志事件到一个flash循环缓冲区，支持通过newtmgr和shell命令行walking和读。

要使用日志记录，通常不需要创建自己的日志处理程序，可以使用预先构建的。一个包或应用程序必须定义struct log的变量，并使用日志包注册一个日志处理程序。必须调用*log_register()*来指定日志处理程序：

```c
log_register(char *name, struct log *log, const struct log_handler *lh, void *arg, uint8_t level)
```

参数：

- name，日志流的名称
- log，注册的日志实例
- lh，日志处理程序的指针，可以指定任意一个预先构建好的日志处理程序：
  - &log_console_hander
  - &log_cbm_hander
  - &log_fcb_handler

- arg，日志处理程序使用的参数，根据指定的日志处理接口不同而不同
  - log_console_handler使用NULL。
  - log_cbm_handler则传递一个指向已经初始化的cbmem结构体指针。
  - log_fcb_handler则传递一个指向已经初始化的fcb_log结构体指针。

通常，一个使用日志记录的包将定义一个struct log类型的全局变量，如*my_package_log*。然后使用默认值调用log_register函数，通常应用程序会覆盖日志记录属性和日志记录的位置。包可以通过两种方式来允许应用程序覆盖这些值：

- 定义应用程序可以设置的系统配置设置，然后包可以使用配置值来调用log_register函数
- 将my_package_log变量设置为外部变量extern，并让应用程序调用log_register来指定特定的日志处理程序。



## 2.2.3 统计数据



## 2.2.4 控制台



## 2.2.5 Shell

Shell是运行在控制台程序之上，提供了以下功能：

- 处理控制台输入
- 通过串口传输实现newtmgr协议





http://mynewt.apache.org/latest/os/modules/system_modules.html